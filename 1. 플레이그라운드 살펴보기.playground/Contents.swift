//: Playground - noun: a place where people can play

import UIKit

 /*
 
 인접 데이터 구조 ( Contiguous data structure )
  데이터를 메모리 영역 중 인접한 부분에 저장한다. 인접 데이터 구조에는 배열, 힙, 메트립스, 해시 테이블 등이 있다.
 
 연결 데이터 구조 ( Linked data structure )
  서로 명확히 구분되는 메모리 영역을 차지하되, 포인터라는 주소체계로 연결, 관리되는 구조이다. 목록, 트리, 그래프 등이 있다.
 
 배열
  Array<Type> , [Type]으로 배열을 선언한다.
 
 */

// var myIntArray: Array<Int> = [1,3,5,7,9]
 var myIntArray: [Int] = [1,3,5,7,9]
 var my2DArray: [[Int]] = [[1,2],[10,11],[20,30]]
 var someSubset = myIntArray[2...4]

/*
    배열 요소 추가
 */

 myIntArray.append(10)
 print(myIntArray)
 myIntArray.insert(4, at: 2)
 print(myIntArray)

/*
   배열 요소 삭제
 */

myIntArray.removeLast()
myIntArray.remove(at: 3)
print(myIntArray)

/*
 
  연결 데이터 구조
  연결 데이터 구조( Linked data structures )는 데이터 타입과 이를 다른 데이터와 묶어주는 포이터로 구성된다.
 여기서 포인터란 메모리상의 위치 주소를 의미한다. C와 같은 로우레벨 프로그래밍 언어와 달리, 스위프트는 직접적으로
 포인터에 접근하지 않으며, 포인터를 활용할 수 있는 별도의 추상 체계를 제공한다. 
 
 */

/*
   알고리즘 개요
  본격적으로 데이터 알고리즘을 학습하기 전에 알고리즘 구현을 위한 자원이 매우 희박한 상태라는 점을 기억해야 한다.
  알고리즘을 작성하려면 시간과 공간이 필요한데 이 두가지야 말로 알고리즘의 가장 중요한 자원인 것이다.
   특히, 우리는 문제의 규모를 측정할 때 이에 투자해야 할 자원의 양을 설명하기 위한 함수의 점근 행동 ( asymptotic behavior )에
  관심을 갖는다. 점근 행동에 대해서는 이장의 후반부에서 다시 설명한다. 점근 행동은 두 개 알고리즘 기법을 비교하는 기초 자료가 되기도 하며,
  특히 문제 해결을 위한 함수의 크기가 커지는 속도보다 자원 소모의 속도가 느리게 증가하는가를 확인할 수 있는 중요한 잣대이기도하다.
  이 말은 좋은 알고리즘이라면 규모가 큰 문제일수록 좀 더 신속하게 해결해야 함을 의미한다.
   이책에서 설명하는 모든 알고리즘을 각각 그에 적합한 데이터 구조를 지니고 있으며, 대부분의 데이터구조에서 다음과 같은 내용은 필수적으로 파악
  하고 있어야 한다.
 
  새로운 데이터 아이템을 삽입하는 방법
  데이터 아이템을 삭제하는 방법
  특정 아이템을 찾는 방법
  모든 데이터 아이템을 순회하는 방법
  데이터 아이템을 정렬하는 방법
 */

/*
 
   벨류 타입과 레퍼런스 타입
  스위프트의 기본 데이터 타입은 벨류 타입과 레퍼런스 타입 두가지다.
  벨류 타입은 오직 하나의 소유 객체만을 지니며, 해당 타입의 데이터가 변수 또는 상수에 할당됐을 때 혹은 함수에 전달됐을 때, 지니고 있던
  값을 복사한다. 벨류 타입에는 다시 구조체와 열거형, 두 가지 유형이 있으며, 스위프트의 모든 데이터 타입은 기본적으로 구조체다.
  반면 레퍼런스 타입은 벨류 타입과 달리 값을 복사하지 않고 공유한다. 즉, 레퍼런스 타입은 변수에 할당하거나 함수에 전달할 때 값을 복사해서
  제공하는 대신, 동일한 이스턴스를 참조값으로 활용한다. 레퍼런스 타입은 여러 개의 소유 객체가 참조라는 방식으로 공유할수 있다.
  여기서 주의 할 점은 이들 데이터 타입은 다른 언어에서와 같은 원천 데이터 타입은 아니라는 것이다. 이들 데이터 타입은 스위프트 표준 라이브러리에서
  구조체타입으로 정의되구 구현된 기명 타입이다.
 
  벨류타입 -> Strueture( Integer, Boolean, Floating Point, Strings, Characters, Tuples, Arrays, Dictionaries, Sets)  , Enumeration
  레퍼런스 타입 -> Classes, Closures
 
 */

/*
   기명 타입과 복합 타입
  스위프트의 또 다른 데이터 타입 분류 체계는 기명타입 ( named types )와 복합 타입이다.
 
  기명 타입은 사용자가 정의할수 있는 데이터 타입이자, 해당 타입이 정의될 당시 특정한 이름을 부여 할 수 있는 타입이다.
  기명타입에는 클래스, 구조체, 열거형, 프로토타입이 있다. 기등 사용자 정의 기명 타입 외에 스위프트 라이브러리에는 배열,
  딕셔너리, 세트, 옵셔널 값을 나타낼수 있는 기명 타입이 별도로 마련돼 있다. 또한 기명 타입은 익스텐션 선억을 통해 동작 범위를 확장 할수 있다.
 
  복합 타입은 별도의 이름이 붙여지지 않은 타입이며, 스위프트에는 function 타비과 type 타입등 두개의 복합 타입이 정의돼 있다. 복합 타입은 기명타압은 물론
  또 다른 복합 타입을 포함할 수 있다 예를 들어, 다음과 같은 튜플 타입은 두개의 요소를 포함한다. 첫번째 요소는 Int라는 기명 타입이고,
  두번째 요소는 (Float, Float )이라는 복합타입이다. ( Int, (Float, Float) )
 */

/*
   타입 에일리어스
  타입 에리리어스 ( type alias )는 기존의 타입을 또 다른 이름으로 부를 수 있는 방법을 제공한다.
 typedef와 유사하다.
 */

typealias TCPPacket = UInt16
var maxTCPPacketsize = TCPPacket.max
maxTCPPacketsize = 65535

/*
   스위프트 표준 라이브러리의 컬렉션 타입
 
  스위프트는 배열, 딕셔너리, 세트등 세 가지의 컬렉션 타입을 제공한다.
  정식 컬렉션 타입은 아니지만 튜플도 있다.
  Swift 4.0 부터는 String 타입도 컬렉션 타입이 되었다.
 */

/*
   점근적 분석
  무한대의 가까운 입력값을 분석하는 데 걸리는 시간을 측정하는 방법이 바로 점금적 분석이고, 이런 분석을 통해
  아래와 같은 닶을 얻을 수 있다.
 */

/*
   삽입형 정렬 알고리즘
   f(x) = cn^2 + q
   f(x) = O(x^2)
 
   병합형 정렬 알고리즘이 삽입형 보다 대규모 데이터에서 증가량이 적게 증가 된다. 
 */








